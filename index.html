<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chess Learner - Your Personal Chess Training Partner</title>
    
    <!-- Local Chess Libraries -->
    <link rel="stylesheet" href="libs/chessboard-1.0.0.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="libs/jquery-3.6.0.min.js"></script>
    <script src="libs/chessboard-1.0.0.min.js"></script>
    <script src="libs/chess.js"></script>
    
    <style>
        /* CSS Variables - Define color scheme and design tokens */
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --danger-color: #e74c3c;
            --background-color: #1a1a1a;
            --card-background: #2d2d2d;
            --text-color: #ffffff;
            --text-secondary: #bdc3c7;
            --border-color: #444;
            --chess-white: #f0d9b5;
            --chess-black: #b58863;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.3);
        }

        /* Reset and Base Styles - Normalize browser defaults */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header Styles - Navigation bar */
        .header {
            background-color: rgba(26, 26, 26, 0.95);
            position: fixed;
            width: 100%;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
        }

        .navbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .nav-brand h1 {
            color: var(--secondary-color);
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-menu {
            display: flex;
            list-style: none;
            gap: 2rem;
        }

        .nav-link {
            color: var(--text-color);
            text-decoration: none;
            transition: color 0.3s;
            font-weight: 500;
            padding: 0.5rem 1rem;
            border-radius: 5px;
        }

        .nav-link:hover, .nav-link.active {
            color: var(--secondary-color);
            background-color: rgba(52, 152, 219, 0.1);
        }

        .hamburger {
            display: none;
            flex-direction: column;
            cursor: pointer;
        }

        .bar {
            width: 25px;
            height: 3px;
            background-color: var(--text-color);
            margin: 3px 0;
            transition: 0.3s;
        }

        /* Main Content - Below header */
        main {
            margin-top: 80px;
        }

        .section {
            display: none;
            min-height: calc(100vh - 80px);
            padding: 2rem 0;
        }

        .section.active {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Hero Section - Landing page */
        .hero {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4rem;
            align-items: center;
            padding: 4rem 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .hero-content h2 {
            font-size: 3.5rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(45deg, var(--secondary-color), var(--accent-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            line-height: 1.2;
        }

        .hero-content p {
            font-size: 1.3rem;
            margin-bottom: 2.5rem;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .hero-buttons {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--secondary-color), #2980b9);
            color: white;
            box-shadow: var(--shadow);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-lg);
        }

        .btn-secondary {
            background-color: transparent;
            color: var(--text-color);
            border: 2px solid var(--secondary-color);
        }

        .btn-secondary:hover {
            background-color: var(--secondary-color);
            color: white;
            transform: translateY(-2px);
        }

        .btn-danger {
            background-color: var(--danger-color);
            color: white;
        }

        .btn-warning {
            background-color: var(--warning-color);
            color: white;
        }

        /* Chess Preview - Animated chess board on hero section */
        .hero-image {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .chess-preview {
            perspective: 1000px;
        }

        .preview-board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            gap: 0;
            border: 10px solid #8B4513;
            border-radius: 5px;
            box-shadow: var(--shadow-lg);
            transform: rotateX(10deg) rotateY(-10deg);
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: rotateX(10deg) rotateY(-10deg) translateY(0); }
            50% { transform: rotateX(10deg) rotateY(-10deg) translateY(-20px); }
        }

        .preview-piece {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .preview-piece:hover {
            transform: scale(1.2);
            z-index: 10;
        }

        .white-piece {
            background-color: var(--chess-white);
            color: #000;
        }

        .black-piece {
            background-color: var(--chess-black);
            color: #fff;
        }

        /* Section Title - Standardized section headers */
        .section-title {
            text-align: center;
            font-size: 2.8rem;
            margin-bottom: 3rem;
            color: var(--text-color);
            position: relative;
        }

        .section-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 4px;
            background: linear-gradient(90deg, var(--secondary-color), var(--accent-color));
            border-radius: 2px;
        }

        /* Game Settings Section - Configuration options */
        .settings-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3rem;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .settings-card {
            background: var(--card-background);
            padding: 2.5rem;
            border-radius: 15px;
            border: 1px solid var(--border-color);
        }

        .settings-card h3 {
            color: var(--secondary-color);
            margin-bottom: 2rem;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.8rem;
            color: var(--text-color);
            font-weight: 600;
        }

        .form-group select, .form-group input {
            width: 100%;
            padding: 12px 15px;
            background-color: #333;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-group select:focus, .form-group input:focus {
            outline: none;
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .form-group input[type="checkbox"] {
            width: auto;
            margin-right: 0.5rem;
        }

        .custom-time {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .custom-time input {
            flex: 1;
        }

        .hidden {
            display: none;
        }

        /* Game Section - Main chess board and game interface */
        .game-container {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 2rem;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .game-board-container {
            background: var(--card-background);
            border-radius: 15px;
            padding: 2rem;
            border: 1px solid var(--border-color);
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .game-header h3 {
            color: var(--secondary-color);
            font-size: 1.5rem;
        }

        .game-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.5rem;
        }

        #game-status {
            font-weight: 600;
            color: var(--text-color);
        }

        /* FIX: Improved Chess Board Layout with Even Spacing */
        .game-board {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 2rem;
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 400px;
            /* Ensure the board maintains aspect ratio with even spacing */
            padding: 1rem;
        }

        #chess-board {
            width: 100%;
            height: auto;
            max-width: min(600px, 90vw);
            aspect-ratio: 1;
            /* Center the board within its container */
            margin: 0 auto;
        }

        .game-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Side Panel - Move history and chat */
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .move-history-panel, .chat-panel {
            background: var(--card-background);
            border-radius: 15px;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .panel-header {
            background: #333;
            padding: 1.2rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }

        .panel-header h3 {
            color: var(--secondary-color);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.2rem;
        }

        /* Move History Controls - Navigation through game moves */
        .move-controls {
            display: flex;
            justify-content: center;
            padding: 1rem;
            background: #333;
            border-bottom: 1px solid var(--border-color);
        }

        .move-btn {
            background: transparent;
            border: none;
            color: var(--text-color);
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
        }

        .move-btn:hover {
            color: var(--secondary-color);
            background: rgba(52, 152, 219, 0.1);
        }

        .move-list {
            padding: 1.5rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .move-pair {
            display: grid;
            grid-template-columns: 40px 1fr 1fr;
            gap: 10px;
            padding: 8px;
            margin-bottom: 5px;
            background: #333;
            border-radius: 5px;
            transition: background 0.2s;
            cursor: pointer;
        }

        .move-pair:hover {
            background: #3a3a3a;
        }

        .move-number {
            color: var(--secondary-color);
            font-weight: bold;
        }

        .white-move, .black-move {
            color: var(--text-color);
            font-family: monospace;
            position: relative;
        }

        .white-move.highlight, .black-move.highlight {
            background: rgba(52, 152, 219, 0.3);
            border-radius: 3px;
        }

        .move-classification {
            position: absolute;
            top: -20px;
            right: 0;
            background: var(--secondary-color);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 10;
            display: none;
        }

        .move-classification.show {
            display: block;
        }

        .no-moves {
            text-align: center;
            color: var(--text-secondary);
            padding: 2rem;
        }

        /* Time Display - Timer for timed games */
        .time-display {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1rem;
            padding: 0.8rem;
            background: #333;
            border-radius: 8px;
        }

        .player-time, .ai-time {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .time-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .time-value {
            font-weight: bold;
            font-size: 1.1rem;
        }

        /* Chat Panel - AI coach interaction */
        .chat-content {
            display: flex;
            flex-direction: column;
            height: 400px;
        }

        .chat-messages {
            flex: 1;
            padding: 1.5rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .chat-message {
            display: flex;
            gap: 1rem;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .ai-avatar {
            background: var(--secondary-color);
            color: white;
        }

        .user-avatar {
            background: var(--success-color);
            color: white;
        }

        .message-content {
            flex: 1;
            background: #333;
            padding: 1rem;
            border-radius: 10px;
            border-top-left-radius: 0;
        }

        .user .message-content {
            border-top-left-radius: 10px;
            border-top-right-radius: 0;
        }

        .chat-input-area {
            display: flex;
            padding: 1.5rem;
            border-top: 1px solid var(--border-color);
            gap: 1rem;
        }

        #chat-input {
            flex: 1;
            padding: 12px 15px;
            background: #333;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-color);
            font-size: 1rem;
        }

        .send-btn {
            background: var(--secondary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .send-btn:hover {
            background: #2980b9;
        }

        /* Puzzle Section - Chess puzzles for training */
        .puzzle-container {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 2rem;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .puzzle-board-container {
            background: var(--card-background);
            border-radius: 15px;
            padding: 2rem;
            border: 1px solid var(--border-color);
        }

        .puzzle-info-panel {
            background: var(--card-background);
            border-radius: 15px;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .puzzle-info-content {
            padding: 1.5rem;
        }

        .puzzle-category, .puzzle-difficulty, .puzzle-hint {
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            padding: 0.8rem;
            background: #333;
            border-radius: 8px;
        }

        .info-label {
            color: var(--text-secondary);
            font-weight: 600;
        }

        .puzzle-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1rem;
        }

        .puzzle-stats {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }

        .puzzle-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.8rem;
            padding: 0.5rem;
            background: #333;
            border-radius: 5px;
        }

        /* FIX: Responsive Puzzle Board with Even Spacing */
        #puzzle-board {
            width: 100%;
            height: auto;
            max-width: min(500px, 90vw);
            aspect-ratio: 1;
            /* Center the board within its container */
            margin: 0 auto;
        }

        /* Stats Section - Player statistics and progress */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }

        .stat-card {
            background: var(--card-background);
            padding: 2rem;
            border-radius: 15px;
            text-align: center;
            border: 1px solid var(--border-color);
            transition: transform 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-icon {
            font-size: 3rem;
            color: var(--secondary-color);
            margin-bottom: 1rem;
        }

        .stat-card h3 {
            color: var(--text-secondary);
            margin-bottom: 1rem;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--text-color);
        }

        /* Game Analysis Modal - Post-game analysis */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }

        .modal-content {
            background-color: var(--card-background);
            margin: 5% auto;
            padding: 0;
            border: 1px solid var(--border-color);
            border-radius: 15px;
            width: 80%;
            max-width: 800px;
            box-shadow: var(--shadow-lg);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 2px solid var(--secondary-color);
        }

        .modal-header h2 {
            color: var(--secondary-color);
            margin: 0;
        }

        .close {
            color: var(--text-secondary);
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: var(--text-color);
        }

        .modal-body {
            padding: 1.5rem;
        }

        .analysis-summary {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .analysis-stat {
            background: #333;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }

        .move-analysis {
            margin-bottom: 2rem;
        }

        .move-analysis h3 {
            color: var(--secondary-color);
            margin-bottom: 1rem;
        }

        .move-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
        }

        .move-stat {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: #333;
            padding: 0.8rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .move-stat:hover {
            background: #3a3a3a;
        }

        .brilliant-icon { color: #9c27b0; }
        .best-icon { color: #2196f3; }
        .good-icon { color: #4caf50; }
        .mistake-icon { color: #ff9800; }
        .blunder-icon { color: #f44336; }

        .analysis-chart {
            height: 200px;
            background: #333;
            border-radius: 8px;
            padding: 1rem;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            padding: 1.5rem;
            border-top: 1px solid var(--border-color);
        }

        /* Notification - System notifications */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--secondary-color);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* Chess Pieces Fix - Ensure proper display of chess pieces */
        #chess-board, #puzzle-board {
            font-family: "Segoe UI Symbol", "Symbola", "DejaVu Sans", "Arial Unicode MS", sans-serif !important;
        }

        .piece {
            font-size: 48px !important;
            line-height: 48px !important;
            width: 48px !important;
            height: 48px !important;
            text-align: center !important;
        }

        /* Move Classification Tooltip - Hover tooltip for move analysis */
        .move-tooltip {
            position: absolute;
            background: var(--card-background);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            z-index: 1000;
            display: none;
            box-shadow: var(--shadow-lg);
            max-width: 300px;
        }

        .move-tooltip.show {
            display: block;
        }

        .move-tooltip h4 {
            color: var(--secondary-color);
            margin-bottom: 5px;
        }

        .move-tooltip p {
            color: var(--text-color);
            font-size: 0.9rem;
            margin: 0;
        }

        /* FIX: Chess Board Highlighting for Click-to-Move */
        .highlight-white {
            box-shadow: inset 0 0 3px 3px yellow;
        }

        .highlight-black {
            box-shadow: inset 0 0 3px 3px yellow;
        }

        /* NEW: Import Game Modal */
        .import-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }

        .import-content {
            background-color: var(--card-background);
            margin: 5% auto;
            padding: 0;
            border: 1px solid var(--border-color);
            border-radius: 15px;
            width: 80%;
            max-width: 600px;
            box-shadow: var(--shadow-lg);
        }

        .import-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 2px solid var(--secondary-color);
        }

        .import-header h2 {
            color: var(--secondary-color);
            margin: 0;
        }

        .import-body {
            padding: 1.5rem;
        }

        .import-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .import-option {
            background: #333;
            padding: 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .import-option:hover {
            background: #3a3a3a;
        }

        .import-option i {
            font-size: 1.5rem;
            color: var(--secondary-color);
        }

        .import-textarea {
            width: 100%;
            min-height: 200px;
            padding: 1rem;
            background: #333;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-color);
            font-family: monospace;
            font-size: 0.9rem;
            resize: vertical;
            display: none;
        }

        .import-footer {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            padding: 1.5rem;
            border-top: 1px solid var(--border-color);
        }

        /* Responsive Design - Media queries for different screen sizes */
        @media (max-width: 1024px) {
            .hero {
                grid-template-columns: 1fr;
                text-align: center;
            }
            
            .game-container {
                grid-template-columns: 1fr;
            }
            
            .settings-container {
                grid-template-columns: 1fr;
            }
            
            .puzzle-container {
                grid-template-columns: 1fr;
            }
            
            .analysis-summary {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .nav-menu {
                display: none;
            }
            
            .hamburger {
                display: flex;
            }
            
            .hero-content h2 {
                font-size: 2.5rem;
            }
            
            .preview-board {
                grid-template-columns: repeat(8, 30px);
                grid-template-rows: repeat(8, 30px);
            }
            
            .preview-piece {
                font-size: 20px;
            }
            
            .hero-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 100%;
                max-width: 300px;
                justify-content: center;
            }
            
            .modal-content {
                width: 95%;
            }
        }

        @media (max-width: 480px) {
            .navbar {
                padding: 1rem;
            }
            
            .hero {
                padding: 2rem 1rem;
            }
            
            .hero-content h2 {
                font-size: 2rem;
            }
            
            .section-title {
                font-size: 2rem;
            }
            
            .game-controls {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
            
            .move-stats {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Header with Navigation -->
    <header class="header">
        <nav class="navbar">
            <div class="nav-brand">
                <h1><i class="fas fa-chess"></i> AI Chess Learner</h1>
            </div>
            <ul class="nav-menu">
                <li><a href="#home" class="nav-link active">Home</a></li>
                <li><a href="#game-settings" class="nav-link">Settings</a></li>
                <li><a href="#game" class="nav-link">Play</a></li>
                <li><a href="#puzzles" class="nav-link">Puzzles</a></li>
                <li><a href="#stats" class="nav-link">Stats</a></li>
            </ul>
            <div class="hamburger">
                <div class="bar"></div>
                <div class="bar"></div>
                <div class="bar"></div>
            </div>
        </nav>
    </header>

    <!-- Main Content Area -->
    <main>
        <!-- Home Section - Landing page -->
        <section id="home" class="section active">
            <div class="hero">
                <div class="hero-content">
                    <h2>Master Chess with an AI That Learns From You</h2>
                    <p>Experience personalized chess training with an AI that adapts to your playing style and helps you improve at your own pace</p>
                    <div class="hero-buttons">
                        <button id="start-playing-btn" class="btn btn-primary"><i class="fas fa-chess-board"></i> Start Playing</button>
                        <button id="start-learning-btn" class="btn btn-secondary"><i class="fas fa-cog"></i> Settings</button>
                        <!-- NEW: Added Puzzles button to home page -->
                        <button id="home-puzzles-btn" class="btn btn-secondary"><i class="fas fa-puzzle-piece"></i> Puzzles</button>
                        <!-- NEW: Added Import Game button to home page -->
                        <button id="import-game-btn" class="btn btn-warning"><i class="fas fa-file-import"></i> Import Game</button>
                        <button id="stats-btn" class="btn btn-secondary"><i class="fas fa-chart-line"></i> View Stats</button>
                    </div>
                </div>
                <div class="hero-image">
                    <div class="chess-preview">
                        <div class="preview-board">
                            <div class="preview-piece white-piece">♜</div><div class="preview-piece black-piece">♞</div><div class="preview-piece white-piece">♝</div><div class="preview-piece black-piece">♛</div>
                            <div class="preview-piece white-piece">♚</div><div class="preview-piece black-piece">♝</div><div class="preview-piece white-piece">♞</div><div class="preview-piece black-piece">♜</div>
                            <div class="preview-piece white-piece">♟</div><div class="preview-piece black-piece">♟</div><div class="preview-piece white-piece">♟</div><div class="preview-piece black-piece">♟</div>
                            <div class="preview-piece white-piece">♟</div><div class="preview-piece black-piece">♟</div><div class="preview-piece white-piece">♟</div><div class="preview-piece black-piece">♟</div>
                            <div class="preview-piece white-piece"></div><div class="preview-piece black-piece"></div><div class="preview-piece white-piece"></div><div class="preview-piece black-piece"></div>
                            <div class="preview-piece white-piece"></div><div class="preview-piece black-piece"></div><div class="preview-piece white-piece"></div><div class="preview-piece black-piece"></div>
                            <div class="preview-piece white-piece"></div><div class="preview-piece black-piece"></div><div class="preview-piece white-piece"></div><div class="preview-piece black-piece"></div>
                            <div class="preview-piece white-piece"></div><div class="preview-piece black-piece"></div><div class="preview-piece white-piece"></div><div class="preview-piece black-piece"></div>
                            <div class="preview-piece white-piece">♙</div><div class="preview-piece black-piece">♙</div><div class="preview-piece white-piece">♙</div><div class="preview-piece black-piece">♙</div>
                            <div class="preview-piece white-piece">♙</div><div class="preview-piece black-piece">♙</div><div class="preview-piece white-piece">♙</div><div class="preview-piece black-piece">♙</div>
                            <div class="preview-piece white-piece">♖</div><div class="preview-piece black-piece">♘</div><div class="preview-piece white-piece">♗</div><div class="preview-piece black-piece">♕</div>
                            <div class="preview-piece white-piece">♔</div><div class="preview-piece black-piece">♗</div><div class="preview-piece white-piece">♘</div><div class="preview-piece black-piece">♖</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Game Settings Section - Configure game parameters -->
        <section id="game-settings" class="section">
            <div class="settings-container">
                <div class="settings-card">
                    <h3><i class="fas fa-cog"></i> Configure Your Game</h3>
                    <div class="form-group">
                        <label for="color-select">Your Color:</label>
                        <select id="color-select">
                            <option value="white">White</option>
                            <option value="black">Black</option>
                            <option value="random">Random</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="difficulty-select">Difficulty:</label>
                        <select id="difficulty-select">
                            <option value="beginner">Beginner</option>
                            <option value="intermediate" selected>Intermediate</option>
                            <option value="advanced">Advanced</option>
                            <option value="expert">Expert</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="personality-select">AI Personality:</label>
                        <select id="personality-select">
                            <option value="balanced" selected>Balanced</option>
                            <option value="tactical">Tactical</option>
                            <option value="aggressive">Aggressive</option>
                            <option value="defensive">Defensive</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="time-control-select">Time Control:</label>
                        <select id="time-control-select">
                            <option value="none">None (Untimed)</option>
                            <option value="bullet-1-0">Bullet: 1 minute</option>
                            <option value="bullet-2-1">Bullet: 2 minutes + 1 second</option>
                            <option value="blitz-3-0">Blitz: 3 minutes</option>
                            <option value="blitz-3-2">Blitz: 3 minutes + 2 seconds</option>
                            <option value="blitz-5-0">Blitz: 5 minutes</option>
                            <option value="rapid-10-0">Rapid: 10 minutes</option>
                            <option value="rapid-15-10">Rapid: 15 minutes + 10 seconds</option>
                            <option value="classical-30-0">Classical: 30 minutes</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="adaptive-difficulty" checked>
                            Enable Adaptive Difficulty (AI adjusts to your skill level)
                        </label>
                    </div>
                    <button id="start-game-btn" class="btn btn-primary"><i class="fas fa-play"></i> Start Game</button>
                </div>
            </div>
        </section>

        <!-- Game Section - Main chess board and game interface -->
        <section id="game" class="section">
            <div class="game-container">
                <div class="game-board-container">
                    <div class="game-header">
                        <h3><i class="fas fa-chess-board"></i> Game Board</h3>
                        <div class="game-info">
                            <div id="game-status">White to move</div>
                            <div class="time-display">
                                <div class="player-time">
                                    <span class="time-label">You:</span>
                                    <span id="player-time" class="time-value">10:00</span>
                                </div>
                                <div class="ai-time">
                                    <span class="time-label">AI:</span>
                                    <span id="ai-time" class="time-value">10:00</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="game-board">
                        <div id="chess-board"></div>
                    </div>
                    <div class="game-controls">
                        <button id="new-game-btn" class="btn btn-primary"><i class="fas fa-redo"></i> New Game</button>
                        <button id="resign-btn" class="btn btn-danger"><i class="fas fa-flag"></i> Resign</button>
                    </div>
                </div>
                
                <div class="side-panel">
                    <div class="move-history-panel">
                        <div class="panel-header">
                            <h3><i class="fas fa-history"></i> Move History</h3>
                        </div>
                        <div class="move-controls">
                            <button id="first-move-btn" class="move-btn"><i class="fas fa-fast-backward"></i></button>
                            <button id="prev-move-btn" class="move-btn"><i class="fas fa-step-backward"></i></button>
                            <button id="play-pause-btn" class="move-btn"><i class="fas fa-play"></i></button>
                            <button id="next-move-btn" class="move-btn"><i class="fas fa-step-forward"></i></button>
                            <button id="last-move-btn" class="move-btn"><i class="fas fa-fast-forward"></i></button>
                        </div>
                        <div class="move-list" id="move-list">
                            <div class="no-moves">No moves yet</div>
                        </div>
                    </div>
                    
                    <div class="chat-panel">
                        <div class="panel-header">
                            <h3><i class="fas fa-robot"></i> AI Coach</h3>
                        </div>
                        <div class="chat-content">
                            <div class="chat-messages" id="chat-messages">
                                <div class="chat-message ai">
                                    <div class="message-avatar ai-avatar"><i class="fas fa-robot"></i></div>
                                    <div class="message-content">
                                        <p>Hello! I'm your AI chess coach. Ready to improve your game?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="chat-input-area">
                                <input type="text" id="chat-input" placeholder="Ask me anything about chess...">
                                <button id="send-chat-btn" class="send-btn"><i class="fas fa-paper-plane"></i></button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Puzzle Section - Chess puzzles for training -->
        <section id="puzzles" class="section">
            <div class="container">
                <h2 class="section-title">Chess Puzzles</h2>
                <div class="puzzle-container">
                    <div class="puzzle-board-container">
                        <div class="game-header">
                            <h3><i class="fas fa-puzzle-piece"></i> Puzzle Board</h3>
                            <div id="puzzle-status">Solve this puzzle</div>
                        </div>
                        <div class="game-board">
                            <div id="puzzle-board"></div>
                        </div>
                        <div class="puzzle-controls">
                            <button id="hint-btn" class="btn btn-secondary"><i class="fas fa-lightbulb"></i> Hint</button>
                            <button id="next-puzzle-btn" class="btn btn-primary"><i class="fas fa-forward"></i> Next Puzzle</button>
                        </div>
                    </div>
                    
                    <div class="puzzle-info-panel">
                        <div class="panel-header">
                            <h3><i class="fas fa-info-circle"></i> Puzzle Info</h3>
                        </div>
                        <div class="puzzle-info-content">
                            <div class="puzzle-category">
                                <span class="info-label">Category:</span>
                                <span id="puzzle-category">Tactics</span>
                            </div>
                            <div class="puzzle-difficulty">
                                <span class="info-label">Difficulty:</span>
                                <span id="puzzle-difficulty">Medium</span>
                            </div>
                            <div class="puzzle-hint" id="puzzle-hint" style="display: none;">
                                <span class="info-label">Hint:</span>
                                <span id="puzzle-hint-text"></span>
                            </div>
                            <div class="puzzle-stats">
                                <div class="puzzle-stat">
                                    <span class="stat-label">Puzzles Solved:</span>
                                    <span id="puzzles-solved">0</span>
                                </div>
                                <div class="puzzle-stat">
                                    <span class="stat-label">Current Streak:</span>
                                    <span id="puzzle-streak">0</span>
                                </div>
                                <div class="puzzle-stat">
                                    <span class="stat-label">Best Streak:</span>
                                    <span id="best-streak">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Stats Section - Player statistics and progress -->
        <section id="stats" class="section">
            <div class="container">
                <h2 class="section-title">Your Learning Progress</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-icon"><i class="fas fa-chess-board"></i></div>
                        <h3>Games Played</h3>
                        <div class="stat-value" id="games-played">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon"><i class="fas fa-percentage"></i></div>
                        <h3>Win Rate</h3>
                        <div class="stat-value" id="win-rate">0%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon"><i class="fas fa-trophy"></i></div>
                        <h3>Current Rating</h3>
                        <div class="stat-value" id="rating">1200</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon"><i class="fas fa-brain"></i></div>
                        <h3>Learning Score</h3>
                        <div class="stat-value" id="learning-score">0</div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- Game Analysis Modal - Post-game analysis -->
    <div id="game-analysis-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-chart-line"></i> Game Analysis</h2>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="analysis-summary">
                    <div class="analysis-stat">
                        <span class="stat-label">Game Result:</span>
                        <span id="game-result">-</span>
                    </div>
                    <div class="analysis-stat">
                        <span class="stat-label">Player Accuracy:</span>
                        <span id="player-accuracy">-</span>
                    </div>
                    <div class="analysis-stat">
                        <span class="stat-label">Your ELO:</span>
                        <span id="player-elo">1200</span>
                    </div>
                    <div class="analysis-stat">
                        <span class="stat-label">AI ELO:</span>
                        <span id="ai-elo">1200</span>
                    </div>
                </div>
                <div class="move-analysis">
                    <h3>Move Classification</h3>
                    <div class="move-stats">
                        <div class="move-stat" data-type="brilliant">
                            <i class="fas fa-star brilliant-icon"></i>
                            <span>Brilliant:</span>
                            <span id="brilliant-count">0</span>
                        </div>
                        <div class="move-stat" data-type="best">
                            <i class="fas fa-check best-icon"></i>
                            <span>Best:</span>
                            <span id="best-count">0</span>
                        </div>
                        <div class="move-stat" data-type="good">
                            <i class="fas fa-thumbs-up good-icon"></i>
                            <span>Good:</span>
                            <span id="good-count">0</span>
                        </div>
                        <div class="move-stat" data-type="mistake">
                            <i class="fas fa-exclamation-triangle mistake-icon"></i>
                            <span>Mistake:</span>
                            <span id="mistake-count">0</span>
                        </div>
                        <div class="move-stat" data-type="blunder">
                            <i class="fas fa-times blunder-icon"></i>
                            <span>Blunder:</span>
                            <span id="blunder-count">0</span>
                        </div>
                    </div>
                </div>
                <div class="analysis-chart">
                    <canvas id="accuracy-chart"></canvas>
                </div>
            </div>
            <div class="modal-footer">
                <button id="close-analysis-btn" class="btn btn-primary">Close</button>
                <button id="download-analysis-btn" class="btn btn-secondary"><i class="fas fa-download"></i> Download Analysis</button>
            </div>
        </div>
    </div>

    <!-- NEW: Import Game Modal -->
    <div id="import-modal" class="import-modal">
        <div class="import-content">
            <div class="import-header">
                <h2><i class="fas fa-file-import"></i> Import Game</h2>
                <span class="close-import">&times;</span>
            </div>
            <div class="import-body">
                <p>Choose how you want to import a chess game for analysis. The AI will evaluate the game but won't learn from it.</p>
                <div class="import-options">
                    <div class="import-option" id="import-pgn-option">
                        <i class="fas fa-file-alt"></i>
                        <div>
                            <h4>Import from PGN</h4>
                            <p>Paste PGN (Portable Game Notation) text</p>
                        </div>
                    </div>
                    <div class="import-option" id="import-fen-option">
                        <i class="fas fa-chess-board"></i>
                        <div>
                            <h4>Import from FEN</h4>
                            <p>Paste FEN (Forsyth-Edwards Notation) text</p>
                        </div>
                    </div>
                    <div class="import-option" id="import-file-option">
                        <i class="fas fa-file-upload"></i>
                        <div>
                            <h4>Import from File</h4>
                            <p>Upload a PGN file from your device</p>
                        </div>
                    </div>
                </div>
                <textarea id="import-textarea" class="import-textarea" placeholder="Paste your PGN or FEN here..."></textarea>
                <input type="file" id="import-file-input" accept=".pgn" style="display: none;">
            </div>
            <div class="import-footer">
                <button id="cancel-import-btn" class="btn btn-secondary">Cancel</button>
                <button id="analyze-imported-btn" class="btn btn-primary" disabled>Analyze Game</button>
            </div>
        </div>
    </div>

    <!-- Move Classification Tooltip - Hover tooltip for move analysis -->
    <div id="move-tooltip" class="move-tooltip">
        <h4 id="tooltip-title">Move Classification</h4>
        <p id="tooltip-content"></p>
    </div>

    <script>
        // Wait for DOM to load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing chess game...');
            
            // API Configuration - Connect to your AI backend
            const API_URL = 'http://127.0.0.1:5000/api';
            
            // Navigation functionality
            const navLinks = document.querySelectorAll('.nav-link');
            const sections = document.querySelectorAll('.section');
            
            navLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // Remove active class from all links and sections
                    navLinks.forEach(l => l.classList.remove('active'));
                    sections.forEach(s => s.classList.remove('active'));
                    
                    // Add active class to clicked link
                    this.classList.add('active');
                    
                    // Show corresponding section
                    const targetId = this.getAttribute('href').substring(1);
                    const targetSection = document.getElementById(targetId);
                    if (targetSection) {
                        targetSection.classList.add('active');
                        
                        // Initialize appropriate board based on section
                        if (targetId === 'game' && !boardInitialized) {
                            setTimeout(initializeChessBoard, 100);
                        } else if (targetId === 'puzzles' && !puzzleBoardInitialized) {
                            setTimeout(initializePuzzleBoard, 100);
                        }
                    }
                });
            });
            
            // Chess game variables
            let board = null;
            let game = null;
            let gameHistory = [];
            let boardInitialized = false;
            let playerColor = 'white';
            let selectedSquare = null;
            let moveAnalysis = [];
            
            // Puzzle variables
            let puzzleBoard = null;
            let puzzleGame = null;
            let currentPuzzle = null;
            let puzzlesSolved = 0;
            let currentStreak = 0;
            let bestStreak = 0;
            let puzzleBoardInitialized = false;
            
            // Move history variables
            let moveHistoryIndex = 0;
            let isPlayingMoves = false;
            let playInterval = null;
            
            // Game analysis variables
            let gameAnalysis = null;
            let adaptiveDifficultyEnabled = true;
            let playerPerformanceHistory = [];
            
            // Time control variables
            let timeControl = null;
            let playerTime = 0;
            let aiTime = 0;
            let timeInterval = null;
            
            // Stats tracking
            let gamesPlayed = 0;
            let gamesWon = 0;
            let gamesLost = 0;
            let gamesDrawn = 0;
            
            // NEW: Import game variables
            let importedGame = null;
            let importedGameAnalysis = null;
            let importType = null; // 'pgn', 'fen', or 'file'
            
            // Enhanced Window resize handler for responsive board
            let resizeTimeout;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(resizeBoards, 250);
            });
            
            // Improved resizeBoards function to handle responsive sizing
            function resizeBoards() {
                if (board) {
                    // Calculate appropriate board size based on viewport
                    const boardContainer = document.querySelector('.game-board');
                    if (boardContainer) {
                        const containerWidth = boardContainer.offsetWidth;
                        const boardSize = Math.min(containerWidth, window.innerHeight * 0.6);
                        
                        // Update board size
                        board.resize();
                        
                        // Update piece sizes proportionally
                        const pieces = document.querySelectorAll('#chess-board .piece');
                        const pieceSize = Math.floor(boardSize / 8 * 0.8);
                        pieces.forEach(piece => {
                            piece.style.fontSize = pieceSize + 'px';
                            piece.style.width = pieceSize + 'px';
                            piece.style.height = pieceSize + 'px';
                            piece.style.lineHeight = pieceSize + 'px';
                        });
                    }
                }
                
                if (puzzleBoard) {
                    // Calculate appropriate board size based on viewport
                    const puzzleContainer = document.querySelector('.puzzle-board .game-board');
                    if (puzzleContainer) {
                        const containerWidth = puzzleContainer.offsetWidth;
                        const boardSize = Math.min(containerWidth, window.innerHeight * 0.5);
                        
                        // Update board size
                        puzzleBoard.resize();
                        
                        // Update piece sizes proportionally
                        const pieces = document.querySelectorAll('#puzzle-board .piece');
                        const pieceSize = Math.floor(boardSize / 8 * 0.8);
                        pieces.forEach(piece => {
                            piece.style.fontSize = pieceSize + 'px';
                            piece.style.width = pieceSize + 'px';
                            piece.style.height = pieceSize + 'px';
                            piece.style.lineHeight = pieceSize + 'px';
                        });
                    }
                }
            }
            
            // Initialize chess board
            function initializeChessBoard() {
                console.log('Initializing chess board...');
                
                // Check if chess.js is loaded
                if (typeof Chess === 'undefined') {
                    console.error('Chess.js library not loaded!');
                    return;
                }
                
                // Check if chessboardjs is loaded
                if (typeof Chessboard === 'undefined') {
                    console.error('Chessboard.js library not loaded!');
                    return;
                }
                
                // Determine player color
                const colorSelect = document.getElementById('color-select');
                if (colorSelect.value === 'random') {
                    playerColor = Math.random() < 0.5 ? 'white' : 'black';
                } else {
                    playerColor = colorSelect.value;
                }
                
                // Initialize game
                game = new Chess();
                gameHistory = [];
                moveHistoryIndex = 0;
                moveAnalysis = [];
                
                // Get board element
                const boardEl = document.getElementById('chess-board');
                if (!boardEl) {
                    console.error('Chess board element not found!');
                    return;
                }
                
                // Check if board already exists
                if (board) {
                    console.log('Board already exists, destroying it first');
                    board.destroy();
                }
                
                // FIX: Remove custom onSquareClick and let chessboard.js handle click-to-move automatically
                console.log('Creating chessboard...');
                board = Chessboard(boardEl, {
                    position: 'start',
                    draggable: true,
                    // Set board orientation based on player color
                    orientation: playerColor,
                    pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
                    onDragStart: onDragStart,
                    onDrop: onDrop,
                    onSnapEnd: onSnapEnd,
                    // FIX: Remove custom click handler - chessboard.js handles this automatically
                    // onMouseoutSquare: onMouseoutSquare,
                    // onMouseoverSquare: onMouseoverSquare,
                    // onSquareClick: onSquareClick
                });
                
                boardInitialized = true;
                
                console.log('Chess board created:', board);
                console.log('Board position:', board.position());
                
                updateStatus();
                updateMoveHistory();
                
                // If player is black, make AI move first
                if (playerColor === 'black') {
                    setTimeout(makeAIMove, 500);
                }
                
                // Start timer if time control is set
                const timeControlValue = document.getElementById('time-control-select').value;
                if (timeControlValue !== 'none') {
                    startTimeControl(timeControlValue);
                }
                
                // Initial board sizing
                setTimeout(resizeBoards, 100);
                
                console.log('=== CHESS BOARD INITIALIZATION COMPLETE ===');
            }
            
            // Initialize puzzle board
            function initializePuzzleBoard() {
                console.log('Initializing puzzle board...');
                
                // Check if chess.js is loaded
                if (typeof Chess === 'undefined') {
                    console.error('Chess.js library not loaded!');
                    return;
                }
                
                // Check if chessboardjs is loaded
                if (typeof Chessboard === 'undefined') {
                    console.error('Chessboard.js library not loaded!');
                    return;
                }
                
                // Initialize puzzle game
                puzzleGame = new Chess();
                
                // Get board element
                const boardEl = document.getElementById('puzzle-board');
                if (!boardEl) {
                    console.error('Puzzle board element not found!');
                    return;
                }
                
                // Check if board already exists
                if (puzzleBoard) {
                    console.log('Puzzle board already exists, destroying it first');
                    puzzleBoard.destroy();
                }
                
                // Initialize board
                console.log('Creating puzzle chessboard...');
                puzzleBoard = Chessboard(boardEl, {
                    position: 'start',
                    draggable: true,
                    pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
                    onDragStart: onPuzzleDragStart,
                    onDrop: onPuzzleDrop,
                    onSnapEnd: onPuzzleSnapEnd,
                    // FIX: Remove custom click handler for puzzle board too
                    // onMouseoutSquare: onMouseoutSquare,
                    // onMouseoverSquare: onMouseoverSquare,
                    // onSquareClick: onPuzzleSquareClick
                });
                
                puzzleBoardInitialized = true;
                
                // Load first puzzle
                loadNextPuzzle();
                
                // Load puzzle stats from localStorage
                const savedPuzzlesSolved = localStorage.getItem('puzzlesSolved');
                const savedBestStreak = localStorage.getItem('bestStreak');
                
                if (savedPuzzlesSolved) puzzlesSolved = parseInt(savedPuzzlesSolved);
                if (savedBestStreak) bestStreak = parseInt(savedBestStreak);
                
                updatePuzzleStats();
                
                // Initial board sizing
                setTimeout(resizeBoards, 100);
                
                console.log('=== PUZZLE BOARD INITIALIZATION COMPLETE ===');
            }
            
            // Chess drag and drop functions
            function onDragStart(source, piece, position, orientation) {
                console.log('Drag start:', source, piece);
                if (game.game_over()) return false;
                
                // Check if it's player's turn
                const isPlayerTurn = (game.turn() === 'w' && playerColor === 'white') || 
                                   (game.turn() === 'b' && playerColor === 'black');
                
                if (!isPlayerTurn) return false;
                
                // Only allow dragging of pieces for the side to move
                if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
                    (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
                    return false;
                }
            }
            
            function onDrop(source, target) {
                console.log('Drop:', source, 'to', target);
                
                // See if the move is legal
                var move = game.move({
                    from: source,
                    to: target,
                    promotion: 'q'
                });
                
                // If illegal move, snapback
                if (move === null) return 'snapback';
                
                console.log('Legal move:', move);
                
                // Add to game history
                gameHistory.push(move.san);
                moveHistoryIndex = gameHistory.length;
                
                // Update the board
                updateBoard();
                
                // Make AI move after a short delay
                if (!game.game_over()) {
                    setTimeout(makeAIMove, 250);
                } else {
                    // Game ended, show analysis
                    clearInterval(timeInterval);
                    setTimeout(analyzeGame, 1000);
                }
            }
            
            function onSnapEnd() {
                console.log('Snap end');
                board.position(game.fen());
            }
            
            // FIX: Remove custom mouse handlers since chessboard.js handles highlighting
            // function onMouseoverSquare(square, piece) {
            //     // Get all legal moves for the selected piece
            //     if (selectedSquare) {
            //         const moves = game.moves({
            //             square: selectedSquare,
            //             verbose: true
            //         });
            //         
            //         // Highlight possible target squares
            //         moves.forEach(move => {
            //             if (move.to === square) {
            //                 $(`.square-${square}`).addClass('highlight-valid');
            //             }
            //         });
            //     }
            // }
            
            // function onMouseoutSquare(square, piece) {
            //     // Remove highlights
            //     $(`.square-${square}`).removeClass('highlight-valid');
            // }
            
            // FIX: Remove custom onSquareClick - chessboard.js handles this automatically
            // function onSquareClick(square) {
            //     // This is now handled by chessboard.js automatically
            // }
            
            // Puzzle drag and drop functions
            function onPuzzleDragStart(source, piece, position, orientation) {
                if (!currentPuzzle) return false;
                
                // Only allow the player to move the side they're supposed to in the puzzle
                const puzzleFen = currentPuzzle.fen;
                const turn = puzzleFen.split(' ')[1];
                
                if ((turn === 'w' && piece.search(/^b/) !== -1) ||
                    (turn === 'b' && piece.search(/^w/) !== -1)) {
                    return false;
                }
            }
            
            function onPuzzleDrop(source, target) {
                if (!currentPuzzle) return 'snapback';
                
                const move = puzzleGame.move({
                    from: source,
                    to: target,
                    promotion: 'q'
                });
                
                if (move === null) return 'snapback';
                
                // Check if the move is correct
                if (move.san === currentPuzzle.solution) {
                    document.getElementById('puzzle-status').textContent = 'Correct! Well done!';
                    puzzlesSolved++;
                    currentStreak++;
                    if (currentStreak > bestStreak) {
                        bestStreak = currentStreak;
                    }
                    updatePuzzleStats();
                    setTimeout(() => {
                        loadNextPuzzle();
                    }, 2000);
                } else {
                    document.getElementById('puzzle-status').textContent = 'Not quite right. Try again!';
                    puzzleGame.undo();
                }
                
                puzzleBoard.position(puzzleGame.fen());
            }
            
            function onPuzzleSnapEnd() {
                puzzleBoard.position(puzzleGame.fen());
            }
            
            // Update board and game status
            function updateBoard() {
                console.log('Updating board...');
                board.position(game.fen());
                updateStatus();
                updateMoveHistory();
            }
            
            function updateStatus() {
                const statusEl = document.getElementById('game-status');
                if (!statusEl) return;
                
                let status = '';
                
                if (game.in_checkmate()) {
                    const winner = game.turn() === 'w' ? 'Black' : 'White';
                    status = 'Game over, ' + winner + ' wins by checkmate.';
                    
                    // Update stats
                    gamesPlayed++;
                    if ((winner === 'White' && playerColor === 'white') || 
                        (winner === 'Black' && playerColor === 'black')) {
                        gamesWon++;
                    } else {
                        gamesLost++;
                    }
                    
                    // Teach AI the result
                    if (winner === 'Black') {
                        teachAI('ai_win');
                    } else {
                        teachAI('player_win');
                    }
                } else if (game.in_draw()) {
                    status = 'Game over, drawn position';
                    gamesPlayed++;
                    gamesDrawn++;
                    teachAI('draw');
                } else if (game.in_check()) {
                    status = (game.turn() === 'w' ? 'White' : 'Black') + ' is in check!';
                } else {
                    status = (game.turn() === 'w' ? 'White' : 'Black') + ' to move';
                }
                
                statusEl.textContent = status;
            }
            
            function updateMoveHistory() {
                const moveListEl = document.getElementById('move-list');
                if (!moveListEl) return;
                
                const history = game.history({ verbose: true });
                
                if (history.length === 0) {
                    moveListEl.innerHTML = '<div class="no-moves">No moves yet</div>';
                    return;
                }
                
                let html = '';
                for (let i = 0; i < history.length; i += 2) {
                    const moveNumber = Math.floor(i / 2) + 1;
                    const whiteMove = history[i];
                    const blackMove = history[i + 1];
                    
                    html += `<div class="move-pair">
                        <span class="move-number">${moveNumber}.</span>
                        <span class="white-move" data-move-index="${i}" data-move="${whiteMove.san}">${whiteMove.san}</span>`;
                    
                    if (blackMove) {
                        html += `<span class="black-move" data-move-index="${i+1}" data-move="${blackMove.san}">${blackMove.san}</span>`;
                    }
                    
                    html += '</div>';
                }
                
                moveListEl.innerHTML = html;
                
                // Add click listeners to moves for classification display
                document.querySelectorAll('.white-move, .black-move').forEach(moveEl => {
                    moveEl.addEventListener('click', function() {
                        const moveIndex = parseInt(this.dataset.moveIndex);
                        showMoveClassification(moveIndex);
                    });
                });
                
                updateMoveHistoryHighlight();
            }
            
            function updateMoveHistoryHighlight() {
                const movePairs = document.querySelectorAll('.move-pair');
                
                movePairs.forEach((pair, index) => {
                    const whiteMove = index * 2;
                    const blackMove = whiteMove + 1;
                    
                    const whiteMoveEl = pair.querySelector('.white-move');
                    const blackMoveEl = pair.querySelector('.black-move');
                    
                    if (whiteMoveEl) {
                        whiteMoveEl.classList.toggle('highlight', whiteMove === moveHistoryIndex - 1);
                    }
                    
                    if (blackMoveEl) {
                        blackMoveEl.classList.toggle('highlight', blackMove === moveHistoryIndex - 1);
                    }
                });
            }
            
            function showMoveClassification(moveIndex) {
                if (!moveAnalysis[moveIndex]) return;
                
                const classification = moveAnalysis[moveIndex];
                const tooltip = document.getElementById('move-tooltip');
                const tooltipTitle = document.getElementById('tooltip-title');
                const tooltipContent = document.getElementById('tooltip-content');
                
                // Set tooltip content
                tooltipTitle.textContent = classification.type.charAt(0).toUpperCase() + classification.type.slice(1);
                tooltipContent.textContent = classification.explanation || 'This move was classified as ' + classification.type;
                
                // Position tooltip near the clicked move
                const moveEl = document.querySelector(`[data-move-index="${moveIndex}"]`);
                if (moveEl) {
                    const rect = moveEl.getBoundingClientRect();
                    tooltip.style.left = rect.left + 'px';
                    tooltip.style.top = (rect.bottom + 5) + 'px';
                }
                
                // Show tooltip
                tooltip.classList.add('show');
                
                // Hide tooltip after 3 seconds
                setTimeout(() => {
                    tooltip.classList.remove('show');
                }, 3000);
            }
            
            // Move history controls
            function goToMove(index) {
                if (index < 0 || index > gameHistory.length) return;
                
                moveHistoryIndex = index;
                
                // Create a new game to replay moves
                const tempGame = new Chess();
                
                for (let i = 0; i < index; i++) {
                    tempGame.move(gameHistory[i]);
                }
                
                board.position(tempGame.fen());
                
                // Update move history highlighting
                updateMoveHistoryHighlight();
            }
            
            function goToPreviousMove() {
                if (moveHistoryIndex > 0) {
                    goToMove(moveHistoryIndex - 1);
                }
            }
            
            function goToNextMove() {
                if (moveHistoryIndex < gameHistory.length) {
                    goToMove(moveHistoryIndex + 1);
                }
            }
            
            function togglePlayMoves() {
                const playBtn = document.getElementById('play-pause-btn');
                
                if (isPlayingMoves) {
                    clearInterval(playInterval);
                    playBtn.innerHTML = '<i class="fas fa-play"></i>';
                    isPlayingMoves = false;
                } else {
                    playBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    isPlayingMoves = true;
                    
                    playInterval = setInterval(() => {
                        if (moveHistoryIndex < gameHistory.length) {
                            goToNextMove();
                        } else {
                            togglePlayMoves();
                        }
                    }, 1000);
                }
            }
            
            // Time control functions
            function startTimeControl(timeControlValue) {
                // Parse time control value
                const parts = timeControlValue.split('-');
                const minutes = parseInt(parts[1]);
                const increment = parts.length > 2 ? parseInt(parts[2]) : 0;
                
                // Set initial times
                playerTime = minutes * 60;
                aiTime = minutes * 60;
                
                // Update display
                updateTimeDisplay();
                
                // Clear any existing interval
                if (timeInterval) clearInterval(timeInterval);
                
                // Start timer
                timeInterval = setInterval(() => {
                    const currentPlayer = playerColor === 'white' ? 'w' : 'b';
                    const currentAI = playerColor === 'white' ? 'b' : 'w';
                    
                    if (game.turn() === currentPlayer) {
                        playerTime -= 1;
                    } else if (game.turn() === currentAI) {
                        aiTime -= 1;
                    }
                    
                    updateTimeDisplay();
                    
                    // Check for timeout
                    if (playerTime <= 0) {
                        clearInterval(timeInterval);
                        alert('Time out! You lose on time.');
                        gamesPlayed++;
                        gamesLost++;
                        teachAI('ai_win');
                        newGame();
                    } else if (aiTime <= 0) {
                        clearInterval(timeInterval);
                        alert('Time out! AI loses on time. You win!');
                        gamesPlayed++;
                        gamesWon++;
                        teachAI('player_win');
                        newGame();
                    }
                    
                    // Add increment after move
                    if (increment > 0 && game.history().length > 0) {
                        const lastMove = game.history()[game.history().length - 1];
                        if (lastMove) {
                            if (game.turn() === currentPlayer) {
                                aiTime += increment;
                            } else {
                                playerTime += increment;
                            }
                        }
                    }
                }, 1000);
            }
            
            function updateTimeDisplay() {
                const playerTimeEl = document.getElementById('player-time');
                const aiTimeEl = document.getElementById('ai-time');
                
                if (playerTimeEl) {
                    playerTimeEl.textContent = formatTime(playerTime);
                }
                
                if (aiTimeEl) {
                    aiTimeEl.textContent = formatTime(aiTime);
                }
            }
            
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
            }
            
            // Puzzle functions
            function loadNextPuzzle() {
                // NEW: Try to get puzzle from AI brain first
                getPuzzleFromAI()
                    .then(puzzle => {
                        if (puzzle) {
                            currentPuzzle = puzzle;
                            puzzleGame.load(puzzle.fen);
                            puzzleBoard.position(puzzle.fen);
                            
                            document.getElementById('puzzle-status').textContent = 'Solve this puzzle';
                            document.getElementById('puzzle-category').textContent = puzzle.category || 'Tactics';
                            document.getElementById('puzzle-difficulty').textContent = puzzle.difficulty || 'Medium';
                            document.getElementById('puzzle-hint').style.display = 'none';
                        } else {
                            // Fallback to predefined puzzles
                            loadPredefinedPuzzle();
                        }
                    })
                    .catch(error => {
                        console.error('Error getting puzzle from AI:', error);
                        // Fallback to predefined puzzles
                        loadPredefinedPuzzle();
                    });
            }
            
            // NEW: Function to get puzzles from AI brain
            async function getPuzzleFromAI() {
                try {
                    const response = await fetch(`${API_URL}/puzzle`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            difficulty: document.getElementById('difficulty-select').value,
                            category: 'mixed',
                            fromHistory: true // Try to get puzzles from game history
                        })
                    });
                    
                    const data = await response.json();
                    return data.puzzle || null;
                } catch (error) {
                    console.error('Error getting puzzle from AI:', error);
                    return null;
                }
            }
            
            // NEW: Function to load predefined puzzles as fallback
            function loadPredefinedPuzzle() {
                const puzzles = [
                    {
                        fen: 'r1bqkb1r/pppp1ppp/2n2n2/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 4 4',
                        solution: 'Nxe5',
                        category: 'Tactics',
                        difficulty: 'Medium',
                        hint: 'Look for a fork!'
                    },
                    {
                        fen: 'rnbqkbnr/ppp2ppp/4p3/3p4/3PP3/8/PPP2PPP/RNBQKBNR w KQkq - 0 3',
                        solution: 'exd5',
                        category: 'Opening',
                        difficulty: 'Easy',
                        hint: 'Open the center!'
                    },
                    {
                        fen: '6k1/5ppp/8/8/8/8/5PPP/6K1 w - - 0 1',
                        solution: 'h4',
                        category: 'Endgame',
                        difficulty: 'Easy',
                        hint: 'Create space for your king!'
                    }
                ];
                
                currentPuzzle = puzzles[Math.floor(Math.random() * puzzles.length)];
                
                puzzleGame.load(currentPuzzle.fen);
                puzzleBoard.position(puzzleGame.fen());
                
                document.getElementById('puzzle-status').textContent = 'Solve this puzzle';
                document.getElementById('puzzle-category').textContent = currentPuzzle.category;
                document.getElementById('puzzle-difficulty').textContent = currentPuzzle.difficulty;
                document.getElementById('puzzle-hint').style.display = 'none';
            }
            
            function showPuzzleHint() {
                if (!currentPuzzle) return;
                
                document.getElementById('puzzle-hint').style.display = 'flex';
                document.getElementById('puzzle-hint-text').textContent = currentPuzzle.hint;
            }
            
            function updatePuzzleStats() {
                document.getElementById('puzzles-solved').textContent = puzzlesSolved;
                document.getElementById('puzzle-streak').textContent = currentStreak;
                document.getElementById('best-streak').textContent = bestStreak;
                
                // Save to localStorage
                localStorage.setItem('puzzlesSolved', puzzlesSolved);
                localStorage.setItem('bestStreak', bestStreak);
            }
            
            // Game Analysis - Connected to AI
            async function analyzeGame() {
                if (!game) return;
                
                // Get current ELO ratings
                const playerElo = parseInt(localStorage.getItem('playerElo') || '1200');
                const aiElo = parseInt(document.getElementById('difficulty-select').value === 'beginner' ? '800' : 
                                     document.getElementById('difficulty-select').value === 'intermediate' ? '1200' : 
                                     document.getElementById('difficulty-select').value === 'advanced' ? '1600' : '2000');
                
                try {
                    // Send game to AI for analysis
                    const response = await fetch(`${API_URL}/analyze`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            game: {
                                moves: game.history(),
                                result: game.in_checkmate() ? (game.turn() === 'w' ? 'Black wins' : 'White wins') : 
                                       game.in_draw() ? 'Draw' : 'Ongoing',
                                playerColor: playerColor,
                                difficulty: document.getElementById('difficulty-select').value
                            }
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.analysis) {
                        gameAnalysis = {
                            result: data.analysis.result,
                            playerAccuracy: data.analysis.accuracy,
                            moveClassifications: data.analysis.moveClassifications,
                            playerElo: playerElo,
                            aiElo: aiElo,
                            moveAnalysis: data.analysis.moveAnalysis || []
                        };
                        
                        // Store move analysis for tooltips
                        moveAnalysis = gameAnalysis.moveAnalysis;
                    } else {
                        // Fallback to simulated analysis
                        gameAnalysis = {
                            result: game.in_checkmate() ? (game.turn() === 'w' ? 'Black wins' : 'White wins') : 'Draw',
                            playerAccuracy: Math.floor(Math.random() * 30) + 70,
                            moveClassifications: {
                                brilliant: Math.floor(Math.random() * 3),
                                best: Math.floor(Math.random() * 5) + 2,
                                good: Math.floor(Math.random() * 8) + 5,
                                mistake: Math.floor(Math.random() * 5) + 2,
                                blunder: Math.floor(Math.random() * 3)
                            },
                            playerElo: playerElo,
                            aiElo: aiElo,
                            moveAnalysis: []
                        };
                    }
                } catch (error) {
                    console.error('Error getting AI analysis:', error);
                    // Fallback to simulated analysis
                    gameAnalysis = {
                        result: game.in_checkmate() ? (game.turn() === 'w' ? 'Black wins' : 'White wins') : 'Draw',
                        playerAccuracy: Math.floor(Math.random() * 30) + 70,
                        moveClassifications: {
                            brilliant: Math.floor(Math.random() * 3),
                            best: Math.floor(Math.random() * 5) + 2,
                            good: Math.floor(Math.random() * 8) + 5,
                            mistake: Math.floor(Math.random() * 5) + 2,
                            blunder: Math.floor(Math.random() * 3)
                        },
                        playerElo: playerElo,
                        aiElo: aiElo,
                        moveAnalysis: []
                    };
                }
                
                // Calculate new ELO based on game result
                let newPlayerElo = playerElo;
                if (gameAnalysis.result === 'White wins' || gameAnalysis.result === 'Black wins') {
                    const isPlayerWin = (gameAnalysis.result === 'White wins' && playerColor === 'white') ||
                                       (gameAnalysis.result === 'Black wins' && playerColor === 'black');
                    
                    if (isPlayerWin) {
                        // Player won - gain ELO
                        newPlayerElo = playerElo + Math.floor(32 * (1 - 1 / (1 + Math.pow(10, (aiElo - playerElo) / 400))));
                    } else {
                        // Player lost - lose ELO
                        newPlayerElo = playerElo + Math.floor(32 * (0 - 1 / (1 + Math.pow(10, (aiElo - playerElo) / 400))));
                    }
                    
                    // Save new ELO
                    localStorage.setItem('playerElo', newPlayerElo.toString());
                }
                
                gameAnalysis.newPlayerElo = Math.floor(newPlayerElo);
                
                // Update adaptive difficulty based on performance
                if (adaptiveDifficultyEnabled) {
                    updateAdaptiveDifficulty();
                }
                
                // Store performance history
                playerPerformanceHistory.push({
                    date: new Date(),
                    accuracy: gameAnalysis.playerAccuracy,
                    result: gameAnalysis.result,
                    elo: newPlayerElo
                });
                
                // Update stats
                updateStats();
                
                // Show the analysis modal
                showAnalysisModal();
            }
            
            // NEW: Function to analyze imported games
            async function analyzeImportedGame() {
                if (!importedGame) return;
                
                try {
                    // Send imported game to AI for analysis
                    const response = await fetch(`${API_URL}/analyze`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            game: {
                                moves: importedGame.history(),
                                result: importedGame.in_checkmate() ? (importedGame.turn() === 'w' ? 'Black wins' : 'White wins') : 
                                       importedGame.in_draw() ? 'Draw' : 'Ongoing',
                                isImported: true, // Flag to indicate this is an imported game
                                doNotLearn: true // Flag to prevent AI from learning
                            }
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.analysis) {
                        importedGameAnalysis = {
                            result: data.analysis.result,
                            playerAccuracy: data.analysis.accuracy,
                            moveClassifications: data.analysis.moveClassifications,
                            moveAnalysis: data.analysis.moveAnalysis || []
                        };
                        
                        // Show analysis modal with imported game data
                        showImportedAnalysisModal();
                    } else {
                        // Fallback to simulated analysis
                        importedGameAnalysis = {
                            result: importedGame.in_checkmate() ? (importedGame.turn() === 'w' ? 'Black wins' : 'White wins') : 'Draw',
                            playerAccuracy: Math.floor(Math.random() * 30) + 70,
                            moveClassifications: {
                                brilliant: Math.floor(Math.random() * 3),
                                best: Math.floor(Math.random() * 5) + 2,
                                good: Math.floor(Math.random() * 8) + 5,
                                mistake: Math.floor(Math.random() * 5) + 2,
                                blunder: Math.floor(Math.random() * 3)
                            },
                            moveAnalysis: []
                        };
                        
                        // Show analysis modal with imported game data
                        showImportedAnalysisModal();
                    }
                } catch (error) {
                    console.error('Error getting AI analysis for imported game:', error);
                    alert('Error analyzing imported game. Please try again.');
                }
            }
            
            // NEW: Function to show analysis modal for imported games
            function showImportedAnalysisModal() {
                // Update modal title
                document.querySelector('#game-analysis-modal .modal-header h2').innerHTML = '<i class="fas fa-file-import"></i> Imported Game Analysis';
                
                // Update modal content with imported game analysis
                document.getElementById('game-result').textContent = importedGameAnalysis.result;
                document.getElementById('player-accuracy').textContent = importedGameAnalysis.playerAccuracy + '%';
                document.getElementById('player-elo').textContent = 'N/A (Imported Game)';
                document.getElementById('ai-elo').textContent = 'N/A (Imported Game)';
                
                document.getElementById('brilliant-count').textContent = importedGameAnalysis.moveClassifications.brilliant;
                document.getElementById('best-count').textContent = importedGameAnalysis.moveClassifications.best;
                document.getElementById('good-count').textContent = importedGameAnalysis.moveClassifications.good;
                document.getElementById('mistake-count').textContent = importedGameAnalysis.moveClassifications.mistake;
                document.getElementById('blunder-count').textContent = importedGameAnalysis.moveClassifications.blunder;
                
                // Add a note that AI won't learn from this game
                const note = document.createElement('p');
                note.textContent = 'Note: The AI will not learn from this imported game.';
                note.style.color = 'var(--warning-color)';
                note.style.marginTop = '1rem';
                note.style.fontStyle = 'italic';
                
                // Remove any existing note
                const existingNote = document.querySelector('#game-analysis-modal .import-note');
                if (existingNote) {
                    existingNote.remove();
                }
                
                // Add the note to the modal
                note.className = 'import-note';
                document.querySelector('#game-analysis-modal .modal-body').appendChild(note);
                
                // Show the modal
                document.getElementById('game-analysis-modal').style.display = 'block';
            }
            
            function showAnalysisModal() {
                // Reset modal title in case it was changed for imported game
                document.querySelector('#game-analysis-modal .modal-header h2').innerHTML = '<i class="fas fa-chart-line"></i> Game Analysis';
                
                // Remove any existing import note
                const existingNote = document.querySelector('#game-analysis-modal .import-note');
                if (existingNote) {
                    existingNote.remove();
                }
                
                document.getElementById('game-result').textContent = gameAnalysis.result;
                document.getElementById('player-accuracy').textContent = gameAnalysis.playerAccuracy + '%';
                document.getElementById('player-elo').textContent = gameAnalysis.playerElo + ' → ' + gameAnalysis.newPlayerElo;
                document.getElementById('ai-elo').textContent = gameAnalysis.aiElo;
                
                document.getElementById('brilliant-count').textContent = gameAnalysis.moveClassifications.brilliant;
                document.getElementById('best-count').textContent = gameAnalysis.moveClassifications.best;
                document.getElementById('good-count').textContent = gameAnalysis.moveClassifications.good;
                document.getElementById('mistake-count').textContent = gameAnalysis.moveClassifications.mistake;
                document.getElementById('blunder-count').textContent = gameAnalysis.moveClassifications.blunder;
                
                // Add click listeners to move classification stats
                document.querySelectorAll('.move-stat').forEach(statEl => {
                    statEl.addEventListener('click', function() {
                        const type = this.dataset.type;
                        showMovesByClassification(type);
                    });
                });
                
                // Draw accuracy chart
                drawAccuracyChart();
                
                document.getElementById('game-analysis-modal').style.display = 'block';
            }
            
            function showMovesByClassification(type) {
                // Find all moves of this classification
                const moves = [];
                const analysis = gameAnalysis || importedGameAnalysis;
                
                if (!analysis || !analysis.moveAnalysis) {
                    alert(`No ${type} moves found in this game.`);
                    return;
                }
                
                analysis.moveAnalysis.forEach((analysisItem, index) => {
                    if (analysisItem.type === type) {
                        const gameHistory = game ? game.history() : importedGame.history();
                        moves.push({
                            move: gameHistory[index],
                            index: index,
                            explanation: analysisItem.explanation
                        });
                    }
                });
                
                if (moves.length === 0) {
                    alert(`No ${type} moves found in this game.`);
                    return;
                }
                
                // Create a list of moves
                let moveList = `${type.charAt(0).toUpperCase() + type.slice(1)} moves:\n\n`;
                moves.forEach(m => {
                    moveList += `${m.index + 1}. ${m.move} - ${m.explanation}\n`;
                });
                
                alert(moveList);
            }
            
            function closeAnalysisModal() {
                document.getElementById('game-analysis-modal').style.display = 'none';
            }
            
            function downloadAnalysis() {
                // Create a text file with the analysis
                const analysis = gameAnalysis || importedGameAnalysis;
                const gameHistory = game ? game.history() : importedGame.history();
                
                let analysisText = `Game Analysis - ${new Date().toLocaleString()}\n\n`;
                analysisText += `Result: ${analysis.result}\n`;
                analysisText += `Player Accuracy: ${analysis.playerAccuracy}%\n`;
                
                if (gameAnalysis) {
                    analysisText += `Player ELO: ${gameAnalysis.playerElo} → ${gameAnalysis.newPlayerElo}\n`;
                    analysisText += `AI ELO: ${gameAnalysis.aiElo}\n`;
                } else {
                    analysisText += `Player ELO: N/A (Imported Game)\n`;
                    analysisText += `AI ELO: N/A (Imported Game)\n`;
                }
                
                analysisText += `\nMove Classifications:\n`;
                analysisText += `Brilliant: ${analysis.moveClassifications.brilliant}\n`;
                analysisText += `Best: ${analysis.moveClassifications.best}\n`;
                analysisText += `Good: ${analysis.moveClassifications.good}\n`;
                analysisText += `Mistake: ${analysis.moveClassifications.mistake}\n`;
                analysisText += `Blunder: ${analysis.moveClassifications.blunder}\n\n`;
                analysisText += `Move History:\n`;
                analysisText += gameHistory.join(', ');
                
                // Create a download link
                const element = document.createElement('a');
                element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(analysisText));
                element.setAttribute('download', `chess-analysis-${Date.now()}.txt`);
                element.style.display = 'none';
                document.body.appendChild(element);
                element.click();
                document.body.removeChild(element);
            }
            
            function drawAccuracyChart() {
                // This would normally use a charting library like Chart.js
                // For now, we'll just create a simple representation
                const canvas = document.getElementById('accuracy-chart');
                const ctx = canvas.getContext('2d');
                
                // Set canvas size
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw a simple line chart showing accuracy over time
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const width = canvas.width;
                const height = canvas.height;
                const padding = 20;
                
                // Draw axes
                ctx.strokeStyle = '#555';
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, height - padding);
                ctx.lineTo(width - padding, height - padding);
                ctx.stroke();
                
                // Draw data points (simulated)
                ctx.fillStyle = '#3498db';
                const dataPoints = playerPerformanceHistory.slice(-10); // Last 10 games
                
                if (dataPoints.length > 0) {
                    const xStep = (width - 2 * padding) / Math.max(dataPoints.length - 1, 1);
                    const yScale = (height - 2 * padding) / 100;
                    
                    dataPoints.forEach((point, index) => {
                        const x = padding + index * xStep;
                        const y = height - padding - point.accuracy * yScale;
                        
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        
                        // Draw point
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                    
                    ctx.strokeStyle = '#3498db';
                    ctx.stroke();
                }
            }
            
            // Adaptive Difficulty
            function updateAdaptiveDifficulty() {
                if (!adaptiveDifficultyEnabled) return;
                
                const difficultySelect = document.getElementById('difficulty-select');
                const currentDifficulty = difficultySelect.value;
                const accuracy = gameAnalysis.playerAccuracy;
                
                // Adjust difficulty based on performance
                if (accuracy > 90 && currentDifficulty !== 'expert') {
                    // Player is doing very well, increase difficulty
                    const difficulties = ['beginner', 'intermediate', 'advanced', 'expert'];
                    const currentIndex = difficulties.indexOf(currentDifficulty);
                    if (currentIndex < difficulties.length - 1) {
                        difficultySelect.value = difficulties[currentIndex + 1];
                        showNotification(`Difficulty increased to ${difficulties[currentIndex + 1]}`);
                    }
                } else if (accuracy < 60 && currentDifficulty !== 'beginner') {
                    // Player is struggling, decrease difficulty
                    const difficulties = ['beginner', 'intermediate', 'advanced', 'expert'];
                    const currentIndex = difficulties.indexOf(currentDifficulty);
                    if (currentIndex > 0) {
                        difficultySelect.value = difficulties[currentIndex - 1];
                        showNotification(`Difficulty decreased to ${difficulties[currentIndex - 1]}`);
                    }
                }
            }
            
            function showNotification(message) {
                // Create a notification element
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;
                
                // Style the notification
                notification.style.position = 'fixed';
                notification.style.bottom = '20px';
                notification.style.right = '20px';
                notification.style.backgroundColor = '#3498db';
                notification.style.color = 'white';
                notification.style.padding = '15px 20px';
                notification.style.borderRadius = '8px';
                notification.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
                notification.style.zIndex = '3000';
                notification.style.opacity = '0';
                notification.style.transition = 'opacity 0.3s';
                
                document.body.appendChild(notification);
                
                // Fade in
                setTimeout(() => {
                    notification.style.opacity = '1';
                }, 10);
                
                // Fade out and remove after 3 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 300);
                }, 3000);
            }
            
            // Stats Management
            function loadStats() {
                // Load stats from localStorage
                const savedGamesPlayed = localStorage.getItem('gamesPlayed');
                const savedGamesWon = localStorage.getItem('gamesWon');
                const savedGamesLost = localStorage.getItem('gamesLost');
                const savedGamesDrawn = localStorage.getItem('gamesDrawn');
                const savedRating = localStorage.getItem('playerElo') || localStorage.getItem('rating');
                const savedLearningScore = localStorage.getItem('learningScore');
                
                if (savedGamesPlayed) {
                    gamesPlayed = parseInt(savedGamesPlayed);
                    document.getElementById('games-played').textContent = gamesPlayed;
                }
                if (savedGamesWon) gamesWon = parseInt(savedGamesWon);
                if (savedGamesLost) gamesLost = parseInt(savedGamesLost);
                if (savedGamesDrawn) gamesDrawn = parseInt(savedGamesDrawn);
                
                // Calculate and display win rate
                if (gamesPlayed > 0) {
                    const winRate = Math.round((gamesWon / gamesPlayed) * 100);
                    document.getElementById('win-rate').textContent = winRate + '%';
                }
                
                if (savedRating) document.getElementById('rating').textContent = savedRating;
                if (savedLearningScore) document.getElementById('learning-score').textContent = savedLearningScore;
            }
            
            function updateStats() {
                // Update games played
                document.getElementById('games-played').textContent = gamesPlayed;
                localStorage.setItem('gamesPlayed', gamesPlayed);
                
                // Update win rate
                if (gamesPlayed > 0) {
                    const winRate = Math.round((gamesWon / gamesPlayed) * 100);
                    document.getElementById('win-rate').textContent = winRate + '%';
                    localStorage.setItem('gamesWon', gamesWon);
                    localStorage.setItem('gamesLost', gamesLost);
                    localStorage.setItem('gamesDrawn', gamesDrawn);
                }
                
                // Update learning score
                const learningScoreEl = document.getElementById('learning-score');
                let learningScore = parseInt(learningScoreEl.textContent);
                learningScore += Math.floor(gameAnalysis.playerAccuracy / 10);
                learningScoreEl.textContent = learningScore;
                localStorage.setItem('learningScore', learningScore);
            }
            
            // AI Move Function - Now uses your AI backend!
            async function makeAIMove() {
                if (game.game_over()) return;
                
                console.log('Getting AI move from backend...');
                
                try {
                    const response = await fetch(`${API_URL}/game/move`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            fen: game.fen(),
                            personality: document.getElementById('personality-select').value,
                            difficulty: document.getElementById('difficulty-select').value
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.move) {
                        console.log('AI responded with move:', data.move);
                        
                        // Make the AI's move
                        const move = game.move({
                            from: data.move.substring(0, 2),
                            to: data.move.substring(2, 4),
                            promotion: data.move.length > 4 ? data.move.substring(4, 5) : 'q'
                        });
                        
                        if (move) {
                            gameHistory.push(move.san);
                            moveHistoryIndex = gameHistory.length;
                            updateBoard();
                            console.log('AI move completed:', move.san);
                        } else {
                            console.error('Invalid AI move:', data.move);
                        }
                    } else {
                        console.error('AI did not return a move');
                    }
                } catch (error) {
                    console.error('Error getting AI move:', error);
                    // Fallback to random move if API fails
                    const legalMoves = game.moves();
                    if (legalMoves.length > 0) {
                        const randomMove = legalMoves[Math.floor(Math.random() * legalMoves.length)];
                        game.move(randomMove);
                        gameHistory.push(randomMove);
                        moveHistoryIndex = gameHistory.length;
                        updateBoard();
                    }
                }
            }
            
            // Teach AI from completed game
            async function teachAI(result) {
                console.log('Teaching AI - Game result:', result);
                
                try {
                    const response = await fetch(`${API_URL}/learn`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            gameData: {
                                game_id: `game_${Date.now()}`,
                                moves: game.history(),
                                result: result,
                                playerColor: playerColor,
                                difficulty: document.getElementById('difficulty-select').value
                            }
                        })
                    });
                    
                    const data = await response.json();
                    console.log('AI learned from game:', data);
                } catch (error) {
                    console.error('Error teaching AI:', error);
                }
            }
            
            // Game controls
            function newGame() {
                if (game) {
                    game.reset();
                    gameHistory = [];
                    moveHistoryIndex = 0;
                    moveAnalysis = [];
                    selectedSquare = null;
                    if (board) {
                        board.position('start');
                    }
                    updateStatus();
                    updateMoveHistory();
                    
                    // Clear timer
                    if (timeInterval) {
                        clearInterval(timeInterval);
                    }
                    
                    // Determine player color for new game
                    const colorSelect = document.getElementById('color-select');
                    if (colorSelect.value === 'random') {
                        playerColor = Math.random() < 0.5 ? 'white' : 'black';
                    } else {
                        playerColor = colorSelect.value;
                    }
                    
                    // Update board orientation when starting a new game
                    if (board && playerColor === 'black') {
                        board.orientation('black');
                    } else if (board) {
                        board.orientation('white');
                    }
                    
                    // If player is black, make AI move first
                    if (playerColor === 'black') {
                        setTimeout(makeAIMove, 500);
                    }
                    
                    // Start timer if time control is set
                    const timeControlValue = document.getElementById('time-control-select').value;
                    if (timeControlValue !== 'none') {
                        startTimeControl(timeControlValue);
                    }
                } else {
                    initializeChessBoard();
                }
            }
            
            // Chat functionality - Connected to AI
            const chatInput = document.getElementById('chat-input');
            const sendChatBtn = document.getElementById('send-chat-btn');
            const chatMessages = document.getElementById('chat-messages');
            
            function addChatMessage(message, isUser = false) {
                if (!chatMessages) return;
                
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${isUser ? 'user' : 'ai'}`;
                
                messageDiv.innerHTML = `
                    <div class="message-avatar ${isUser ? 'user-avatar' : 'ai-avatar'}">
                        <i class="fas fa-${isUser ? 'user' : 'robot'}"></i>
                    </div>
                    <div class="message-content">
                        <p>${message}</p>
                    </div>
                `;
                
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            
            async function sendChatMessage() {
                if (!chatInput) return;
                
                const message = chatInput.value.trim();
                if (!message) return;
                
                // Add user message
                addChatMessage(message, true);
                
                // Clear input
                chatInput.value = '';
                
                try {
                    const response = await fetch(`${API_URL}/chat`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            message: message,
                            context: {
                                currentGame: game ? game.fen() : null,
                                playerColor: playerColor,
                                gameHistory: gameHistory
                            }
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.response) {
                        addChatMessage(data.response);
                    }
                } catch (error) {
                    console.error('Error sending chat message:', error);
                    // Fallback response
                    addChatMessage("I'm having trouble connecting right now, but I'm here to help!");
                }
            }
            
            // NEW: Import Game Functions
            function showImportModal() {
                document.getElementById('import-modal').style.display = 'block';
            }
            
            function closeImportModal() {
                document.getElementById('import-modal').style.display = 'none';
                // Reset import form
                document.getElementById('import-textarea').value = '';
                document.getElementById('import-textarea').style.display = 'none';
                document.getElementById('analyze-imported-btn').disabled = true;
                importType = null;
            }
            
            function handleImportOption(option) {
                // Reset all options
                document.querySelectorAll('.import-option').forEach(el => {
                    el.style.background = '#333';
                });
                
                // Highlight selected option
                option.style.background = 'rgba(52, 152, 219, 0.2)';
                
                // Show appropriate input method
                const textarea = document.getElementById('import-textarea');
                const fileInput = document.getElementById('import-file-input');
                
                if (option.id === 'import-pgn-option') {
                    importType = 'pgn';
                    textarea.placeholder = 'Paste your PGN (Portable Game Notation) here...';
                    textarea.style.display = 'block';
                    fileInput.style.display = 'none';
                } else if (option.id === 'import-fen-option') {
                    importType = 'fen';
                    textarea.placeholder = 'Paste your FEN (Forsyth-Edwards Notation) here...';
                    textarea.style.display = 'block';
                    fileInput.style.display = 'none';
                } else if (option.id === 'import-file-option') {
                    importType = 'file';
                    textarea.style.display = 'none';
                    fileInput.style.display = 'block';
                    fileInput.click();
                }
            }
            
            function processImportedData() {
                const textarea = document.getElementById('import-textarea');
                const fileInput = document.getElementById('import-file-input');
                
                if (importType === 'pgn') {
                    const pgnText = textarea.value.trim();
                    if (!pgnText) {
                        alert('Please enter PGN data.');
                        return;
                    }
                    
                    try {
                        importedGame = new Chess();
                        const pgnResult = importedGame.load_pgn(pgnText);
                        
                        if (!pgnResult) {
                            throw new Error('Invalid PGN format');
                        }
                        
                        // Enable analyze button
                        document.getElementById('analyze-imported-btn').disabled = false;
                        showNotification('PGN loaded successfully. Click "Analyze Game" to continue.');
                    } catch (error) {
                        alert('Error loading PGN: ' + error.message);
                    }
                } else if (importType === 'fen') {
                    const fenText = textarea.value.trim();
                    if (!fenText) {
                        alert('Please enter FEN data.');
                        return;
                    }
                    
                    try {
                        importedGame = new Chess();
                        const fenResult = importedGame.load(fenText);
                        
                        if (!fenResult) {
                            throw new Error('Invalid FEN format');
                        }
                        
                        // Enable analyze button
                        document.getElementById('analyze-imported-btn').disabled = false;
                        showNotification('FEN loaded successfully. Click "Analyze Game" to continue.');
                    } catch (error) {
                        alert('Error loading FEN: ' + error.message);
                    }
                } else if (importType === 'file') {
                    const file = fileInput.files[0];
                    if (!file) {
                        alert('Please select a PGN file.');
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            importedGame = new Chess();
                            const pgnResult = importedGame.load_pgn(e.target.result);
                            
                            if (!pgnResult) {
                                throw new Error('Invalid PGN format in file');
                            }
                            
                            // Enable analyze button
                            document.getElementById('analyze-imported-btn').disabled = false;
                            showNotification('PGN file loaded successfully. Click "Analyze Game" to continue.');
                        } catch (error) {
                            alert('Error loading PGN file: ' + error.message);
                        }
                    };
                    
                    reader.readAsText(file);
                }
            }
            
            // Event Listeners
            // Game controls
            document.getElementById('new-game-btn').addEventListener('click', newGame);
            
            document.getElementById('resign-btn').addEventListener('click', function() {
                if (confirm('Are you sure you want to resign?')) {
                    const winner = playerColor === 'white' ? 'Black' : 'White';
                    alert(`${winner} wins by resignation!`);
                    
                    // Update stats
                    gamesPlayed++;
                    gamesLost++;
                    
                    // Teach AI the result
                    if (winner === 'Black') {
                        teachAI('ai_win');
                    } else {
                        teachAI('player_win');
                    }
                    
                    // Clear timer
                    if (timeInterval) {
                        clearInterval(timeInterval);
                    }
                    
                    newGame();
                }
            });
            
            // Move history controls
            document.getElementById('first-move-btn').addEventListener('click', () => goToMove(0));
            document.getElementById('prev-move-btn').addEventListener('click', goToPreviousMove);
            document.getElementById('play-pause-btn').addEventListener('click', togglePlayMoves);
            document.getElementById('next-move-btn').addEventListener('click', goToNextMove);
            document.getElementById('last-move-btn').addEventListener('click', () => goToMove(gameHistory.length));
            
            // Puzzle controls
            document.getElementById('hint-btn').addEventListener('click', showPuzzleHint);
            document.getElementById('next-puzzle-btn').addEventListener('click', loadNextPuzzle);
            
            // Settings
            document.getElementById('adaptive-difficulty').addEventListener('change', (e) => {
                adaptiveDifficultyEnabled = e.target.checked;
            });
            
            document.getElementById('time-control-select').addEventListener('change', function() {
                if (game && boardInitialized) {
                    const timeControlValue = this.value;
                    if (timeControlValue !== 'none') {
                        startTimeControl(timeControlValue);
                    } else {
                        if (timeInterval) {
                            clearInterval(timeInterval);
                        }
                    }
                }
            });
            
            // Add event listener for color change to flip board
            document.getElementById('color-select').addEventListener('change', function() {
                if (board && boardInitialized) {
                    const newColor = this.value === 'random' ? 
                        (Math.random() < 0.5 ? 'white' : 'black') : 
                        this.value;
                    
                    board.orientation(newColor);
                    playerColor = newColor;
                }
            });
            
            // Chat
            if (sendChatBtn) {
                sendChatBtn.addEventListener('click', sendChatMessage);
            }
            
            if (chatInput) {
                chatInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        sendChatMessage();
                    }
                });
            }
            
            // Modal controls
            document.querySelector('.close').addEventListener('click', closeAnalysisModal);
            document.getElementById('close-analysis-btn').addEventListener('click', closeAnalysisModal);
            document.getElementById('download-analysis-btn').addEventListener('click', downloadAnalysis);
            
            // NEW: Import game modal controls
            document.getElementById('import-game-btn').addEventListener('click', showImportModal);
            document.querySelector('.close-import').addEventListener('click', closeImportModal);
            document.getElementById('cancel-import-btn').addEventListener('click', closeImportModal);
            
            // Import option handlers
            document.getElementById('import-pgn-option').addEventListener('click', function() {
                handleImportOption(this);
            });
            
            document.getElementById('import-fen-option').addEventListener('click', function() {
                handleImportOption(this);
            });
            
            document.getElementById('import-file-option').addEventListener('click', function() {
                handleImportOption(this);
            });
            
            // Process imported data when textarea changes
            document.getElementById('import-textarea').addEventListener('input', function() {
                if (this.value.trim()) {
                    document.getElementById('analyze-imported-btn').disabled = false;
                } else {
                    document.getElementById('analyze-imported-btn').disabled = true;
                }
            });
            
            // Analyze imported game
            document.getElementById('analyze-imported-btn').addEventListener('click', function() {
                if (!importedGame) {
                    processImportedData();
                } else {
                    closeImportModal();
                    analyzeImportedGame();
                }
            });
            
            // Tooltip close on click outside
            document.addEventListener('click', function(e) {
                const tooltip = document.getElementById('move-tooltip');
                if (!tooltip.contains(e.target)) {
                    tooltip.classList.remove('show');
                }
            });
            
            // Start game button
            document.getElementById('start-game-btn').addEventListener('click', function() {
                console.log('Start game button clicked');
                // Switch to game section
                navLinks.forEach(l => l.classList.remove('active'));
                sections.forEach(s => s.classList.remove('active'));
                
                document.querySelector('[href="#game"]').classList.add('active');
                document.getElementById('game').classList.add('active');
                
                // Initialize board
                setTimeout(initializeChessBoard, 100);
            });
            
            // Hero buttons
            document.getElementById('start-learning-btn').addEventListener('click', function() {
                navLinks.forEach(l => l.classList.remove('active'));
                sections.forEach(s => s.classList.remove('active'));
                
                document.querySelector('[href="#game-settings"]').classList.add('active');
                document.getElementById('game-settings').classList.add('active');
            });
            
            document.getElementById('stats-btn').addEventListener('click', function() {
                navLinks.forEach(l => l.classList.remove('active'));
                sections.forEach(s => s.classList.remove('active'));
                
                document.querySelector('[href="#stats"]').classList.add('active');
                document.getElementById('stats').classList.add('active');
            });
            
            document.getElementById('start-playing-btn').addEventListener('click', function() {
                console.log('Start playing button clicked');
                // Switch to game section
                navLinks.forEach(l => l.classList.remove('active'));
                sections.forEach(s => s.classList.remove('active'));
                
                document.querySelector('[href="#game"]').classList.add('active');
                document.getElementById('game').classList.add('active');
                
                // Initialize board
                setTimeout(initializeChessBoard, 100);
            });
            
            // NEW: Home page puzzles button
            document.getElementById('home-puzzles-btn').addEventListener('click', function() {
                navLinks.forEach(l => l.classList.remove('active'));
                sections.forEach(s => s.classList.remove('active'));
                
                document.querySelector('[href="#puzzles"]').classList.add('active');
                document.getElementById('puzzles').classList.add('active');
                
                // Initialize puzzle board if not already done
                if (!puzzleBoardInitialized) {
                    setTimeout(initializePuzzleBoard, 100);
                }
            });
            
            // Settings: Time control custom input
            const timeControlSelect = document.getElementById('time-control-select');
            const customTimeDiv = document.getElementById('custom-time');
            
            if (timeControlSelect && customTimeDiv) {
                timeControlSelect.addEventListener('change', function() {
                    if (this.value === 'custom') {
                        customTimeDiv.classList.remove('hidden');
                    } else {
                        customTimeDiv.classList.add('hidden');
                    }
                });
            }
            
            // Load stats from localStorage
            loadStats();
            
            console.log('Chess game script loaded successfully!');
        });
    </script>
</body>
</html>